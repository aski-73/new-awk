options {
    STATIC = false;
    DEBUG_PARSER = true;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(NawkParser)
import java.io.File;import java.io.FileReader;

public class NawkParser {
    public static void main(String[] args) {
        try {
          if (args.length == 0) {
            NawkParser parser = new NawkParser(NawkParser.class.getResourceAsStream("myawk.nawk"));
            parser.start();
          } else {
            for (String arg: args) {
              File testFile =
                      new File(arg);
              NawkParser parser = new NawkParser(new FileReader(testFile));
              parser.start();
            }
          }
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}

PARSER_END(NawkParser)

/* LEXER RULES  */

TOKEN : {
    // OPERATORS
      <PLUS :"+">
    | <MINUS: "-">
    | <STAR: "*">
    | <SLASH: "/">
    | <MOD: "%">
    | <EXP: "^">
    | <ASSIGN: "=">
    | <BANG: "!">
    | <GT: ">">
    | <LT: "<">
    | <EQ: "==">
    | <LE: "<=">
    | <GE: ">=">
    | <NE: "!=">
    | <OR: "||">
    | <AND: "&&">
    // SEPERATORS
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <SEMICOLON: ";">
    | <COMMA: ",">
    // TYPES
    | "double" | "int" | "print" | "string" | "boolean" | "char"
    // OTHER
    | <VOID: "void">
    | <TRUE: "true">
    | <FALSE: "false">
    | <RETURN: "return">
    | <DOT: ".">
    // LITERALS (Values)
    | <INTEGER_LITERAL : "0" | ["1" - "9"] (["0" - "9"])*>
    | <DOUBLE_LITERAL : <INTEGER_LITERAL> "." (["0" - "9"])*>
    | <CHAR_LTIERAL : "'" (["a"-"z", "A"-"Z"]){1} "'">
    | <STRING_LITERAL : "\"" (~["\""])* "\""> // innerhalb Gänsefüßchen alles bis auf weitere Gänsefüßen matchen
    | <Ident : ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*>
}

// Ignore in syntax, lexer analysis
SKIP : {
    " "
    | "\t"
    | <anything: ~[]> // anything else that the Lexer does not know
}

/* PARSER RULES */

// Root-Regel
void start() : {
}{
    prog() <EOF>
}

void prog() : {
    SymbolTable globalSt = new SymbolTable(null);
} {
    // Needs Lookahead so that a fieldDeclaration and functionDeclaration can be differentiated
    ( LOOKAHEAD(3) statement(globalSt) | functionDeclaration())*
}

/** STATEMENTS **/

void statement(SymbolTable st) : {
} {
    fieldDeclaration(st)
    | blockStatement(st)
    | exprStatement(st)
    | emptyStatement()
}

void blockStatement(SymbolTable parentSt) : {
        SymbolTable st = new SymbolTable(parentSt);
} {
    "{"  blockStatementContent(st) "}"
}

// Workaround, da (..)* in blockStatement nicht stehen kann, ohne dass
// javecc unreachable code erzeugt
void blockStatementContent(SymbolTable st) : {
} {
    (statement(st))*
}

void exprStatement(SymbolTable st) : {
} {
    expr() ";"
}
void emptyStatement() : {
} {
    ";"
}

/** FIELD DECLARATION **/

void type() :
{}
{
  primitiveType() ( "[" "]" )*
}

void primitiveType() : {}
{
   "boolean"
   | "char"
   | "int"
   | "double"
   | "string"
}

void fieldDeclaration(SymbolTable st) : {}
{
  type() variableDeclarator() ";"
}

void variableDeclarator() : {}
{
  variableDeclaratorId() [ "=" variableInitializer() ]
}

void variableDeclaratorId() : {}
{
  <Ident> ( "[" "]" )*
}

void variableInitializer() : {}
{
  arrayInitializer()
  | expr()
}

void arrayInitializer() : {}
{
  "{" [ variableInitializer() ("," variableInitializer())* ] "}"
}

/** FUNCTION DECLARATION **/

void functionDeclaration() : {
    // No Parent table, because a function can not access outer scope
    SymbolTable st = new SymbolTable(null);
} {
    resultType() <Ident> "(" functionParameters() ")" functionBlock(st)
}

void resultType() : {} {
    "void" | type()
}

void functionParameters() : {} {
    [ type() variableDeclarator() ("," type() variableDeclarator())*]
}

void functionBlock(SymbolTable st) : {} {
    "{" (statement(st))* ["return" expr() ";"] "}"
}

/** EXPRESSIONS **/

void expr(): {} {
    conditionalOrExpression()
}

void conditionalOrExpression() : {}
{
    conditionalAndExpression() ( "||" conditionalAndExpression() )*
}

void conditionalAndExpression() : {}
{
    equalityExpression() ( "&&" equalityExpression() )*
}

void equalityExpression() : {}
{
    relationalExpression() ( ( "==" | "!=" ) relationalExpression() )*
}

void relationalExpression() : {}
{
    additiveExpression() ( ( "<" | ">" | "<=" | ">=" ) additiveExpression() )*
}

void additiveExpression() : {}
{
    multiplicativeExpression() ( ( "+" | "-" ) multiplicativeExpression() )*
}

void multiplicativeExpression() : {}
{
    unaryExpression() ( ( "*" | "/" | "%" ) unaryExpression() )*
}

void unaryExpression() : {}
{
    ["+" | "-" | "!"] primaryExpression()
}

void primaryExpression() : {}
{
    literal() [primarySuffix()]
}

void primarySuffix() : {} {
    ["." <Ident>] arguments() // .length(), toDouble() etc.
}


void arguments() :
{}
{
  "(" [ argumentList() ] ")"
}

void argumentList() :
{}
{
  variableInitializer() ( "," variableInitializer() )*
}

void literal() : {}
{
    <INTEGER_LITERAL>
    | <DOUBLE_LITERAL>
    | <CHAR_LTIERAL>
    | <STRING_LITERAL>
    | booleanLiteral()
    | <Ident>
}
void booleanLiteral() : {}
{
    "true" | "false"
}

JAVACODE
Node skipError(int kind) {
    ParseException e = generateParseException();
    System.out.println("Hello " + e.toString());
    Token t;
    do {
        t = getNextToken();
    } while (t.kind != kind);
    return null;
}