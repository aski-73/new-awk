options {
    STATIC = false;
//    DEBUG_PARSER = true;
//    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(NawkParser)
import ast.SymbolTable; import ast.Node; import ast.Variable; import java.io.File;import java.io.FileReader;

public class NawkParser {
    public static void main(String[] args) {
        try {
          if (args.length == 0) {
            NawkParser parser = new NawkParser(NawkParser.class.getResourceAsStream("myawk.nawk"));
            parser.start();
          } else {
            for (String arg: args) {
              File testFile =
                      new File(arg);
              NawkParser parser = new NawkParser(new FileReader(testFile));
              parser.start();
            }
          }
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}

PARSER_END(NawkParser)

/* LEXER RULES  */

TOKEN : {
    // OPERATORS
      <PLUS :"+">
    | <MINUS: "-">
    | <STAR: "*">
    | <SLASH: "/">
    | <MOD: "%">
    | <EXP: "^">
    | <ASSIGN: "=">
    | <BANG: "!">
    | <GT: ">">
    | <LT: "<">
    | <EQ: "==">
    | <LE: "<=">
    | <GE: ">=">
    | <NE: "!=">
    | <OR: "||">
    | <AND: "&&">
    // SEPERATORS
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <SEMICOLON: ";">
    | <COMMA: ",">
    // TYPES
    | <DOUBLE: "double">
    | <INTEGER: "int">
    | <STRING: "string">
    | <BOOLEAN: "boolean">
    | <CHAR: "char">
    // OTHER
    | <VOID: "void">
    | <TRUE: "true">
    | <FALSE: "false">
    | <RETURN: "return">
    | <DOT: ".">
    | <PRINT: "print">
    // LITERALS (Values)
    | <INTEGER_LITERAL : "0" | ["1" - "9"] (["0" - "9"])*>
    | <DOUBLE_LITERAL : <INTEGER_LITERAL> "." (["0" - "9"])*>
    | <CHAR_LTIERAL : "'" (["a"-"z", "A"-"Z"]){1} "'">
    | <STRING_LITERAL : "\"" (~["\""])* "\""> // innerhalb Gänsefüßchen alles bis auf weitere Gänsefüßen matchen
    | <Ident : ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*>
}

// Ignore in syntax, lexer analysis
SKIP : {
    " "
    | "\t"
    | <anything: ~[]> // anything else that the Lexer does not know
}

/* PARSER RULES */

// Root-Regel
void start() : {
}{
    prog() <EOF>
}

void prog() : {
    SymbolTable globalSt = new SymbolTable(null);
} {
    // Needs Lookahead so that a variableDeclaration and functionDeclaration can be differentiated
    ( LOOKAHEAD(3) statement(globalSt) | functionDeclaration())*
}

/** STATEMENTS **/

void statement(SymbolTable st) : {
} {
    variableDeclaration(st)
    | blockStatement(st)
    | exprStatement(st)
    | emptyStatement()
}

void blockStatement(SymbolTable parentSt) : {
        SymbolTable st = new SymbolTable(parentSt);
} {
    "{" blockStatementContent(st) "}"
}

// Workaround, da (..)* in blockStatement nicht stehen kann, ohne dass
// javecc unreachable code erzeugt
void blockStatementContent(SymbolTable st) : {
} {
    (statement(st))*
}

void exprStatement(SymbolTable st) : {
} {
    expr(st) ";"
}
void emptyStatement() : {
} {
    ";"
}

/** FIELD DECLARATION **/

Token type() :
{
    Token type;
} {
    type = primitiveType() ( "[" "]" )* {return type;}
}

Token primitiveType() : {
    Token t;
} {
   (t = "boolean"
   | t = "char"
   | t = "int"
   | t = "double"
   | t = "string") {return t;}
}

void variableDeclaration(SymbolTable st) : {
    Token type;
    Variable variable;
} {
  type = type() variable = variableDeclarator(st) {st.add(variable.identifier, type.image);} ";"
}

Variable variableDeclarator(SymbolTable st) : {
    Token id;
} {
  id = variableDeclaratorId() [ "=" variableInitializer(st) ] {return new Variable(id.image, "");}
}

Token variableDeclaratorId() : {
    Token id;
} {
  id = <Ident> ( "[" "]" )* {return id;}
}

void variableInitializer(SymbolTable st) : {}
{
  arrayInitializer(st)
  | expr(st)
}

void arrayInitializer(SymbolTable st) : {}
{
  "{" [ variableInitializer(st) ("," variableInitializer(st))* ] "}"
}

/** FUNCTION DECLARATION **/

void functionDeclaration() : {
    // No Parent table, because a function can not access outer scope
    SymbolTable st = new SymbolTable(null);
} {
    resultType() <Ident> "(" functionParameters(st) ")" functionBlock(st)
}

void resultType() : {} {
    "void" | type()
}

void functionParameters(SymbolTable st) : {} {
    [ type() variableDeclarator(st) ("," type() variableDeclarator(st))*]
}

void functionBlock(SymbolTable st) : {} {
    "{" (statement(st))* ["return" expr(st) ";"] "}"
}

/** EXPRESSIONS **/

String expr(SymbolTable st): {
    String left, right = null;
    Token op = null;
 } {
    // define variable assignment in expression rule, since expr can evaluate to an identifier
    left = conditionalOrExpression(st) [<ASSIGN> right = expr(st) ] {
        return validateTypes(left, right, op);
    }
}

String conditionalOrExpression(SymbolTable st) : {
     String left, right = null;
     Token op = null;
 } {
    left = conditionalAndExpression(st) ( "||" right = conditionalAndExpression(st) )* {
        return validateTypes(left, right, op);
    }
}

String conditionalAndExpression(SymbolTable st) : {
     String left, right = null;
     Token op = null;
 } {
    left = equalityExpression(st) ( "&&" right = equalityExpression(st) )* {
        return validateTypes(left, right, op);
    }
}

String equalityExpression(SymbolTable st) : {
     String left, right = null;
     Token op = null;
 } {
    left = relationalExpression(st) ( ( "==" | "!=" ) right = relationalExpression(st) )* {
        return validateTypes(left, right, op);
    }
}

String relationalExpression(SymbolTable st) : {
     String left, right = null;
     Token op = null;
 } {
    left = additiveExpression(st) ( ( "<" | ">" | "<=" | ">=" ) right = additiveExpression(st) )* {
        return validateTypes(left, right, op);
    }
}

String additiveExpression(SymbolTable st) : {
     String left, right = null;
     Token op = null;
 } {
    left = multiplicativeExpression(st) ( ( op = "+" | op = "-" ) right = multiplicativeExpression(st) )* {
        return validateTypes(left, right, op);
    }
}

/**
* Rules in multiplication:
 OK:       Arithmetic with numeric values (int, double, char)

* Not OK:   Arithmetic with non-numeric values (string, boolean)
* @returns Type of the expression
*/
String multiplicativeExpression(SymbolTable st) : {
    String left, right = null;
    Token op = null;
 } {
    left = unaryExpression(st) ( ( op = "*" | op = "/" | op = "%" ) right = unaryExpression(st) )* {
        return validateTypes(left, right, op);
    }
}

String unaryExpression(SymbolTable st) : {
    Token t;
    String type;
 } {
    [t = "+" | t = "-" | t = "!"] type = primaryExpression(st) {return type;}
}

String primaryExpression(SymbolTable st) : {
    String type;
 } {
    type = literal(st) [primarySuffix(st)] {return type;}
}

void primarySuffix(SymbolTable st) : {} {
    ["." <Ident>] arguments(st) // .length(), toDouble() etc.
    | ("[" expr(st) "]")+ // Array Zugriff
}


void arguments(SymbolTable st) :
{}
{
  "(" [ argumentList(st) ] ")"
}

void argumentList(SymbolTable st) :
{}
{
  variableInitializer(st) ( "," variableInitializer(st) )*
}

String literal(SymbolTable st) : {
    Token id;
    // User intended type for the variable
    String type;
} {
    ( <INTEGER_LITERAL> { type = "int";}
    | <DOUBLE_LITERAL>  { type = "double";}
    | <CHAR_LTIERAL>    { type = "char";}
    | <STRING_LITERAL>  { type = "string";}
    | booleanLiteral()  { type = "boolean";}
    | id = <Ident> {
        if (st.find(id.image) == null)  {
            System.out.printf("Variable '%s' is not defined yet.%n", id.image);
            type = "error";
        } else {
            type = st.find(id.image);
        }
    }
    | "(" type = expr(st)")") {return type;} // return type when one rule in the "()" is succefully applied
}
void booleanLiteral() : {}
{
    "true" | "false"
}

JAVACODE
Node skipError(int kind) {
    ParseException e = generateParseException();
    System.out.println("Hello " + e.toString());
    Token t;
    do {
        t = getNextToken();
    } while (t.kind != kind);
    return null;
}

JAVACODE
boolean isNumeric(String type) {
    return type.equals("int") || type.equals("char") || type.equals("double");
}

JAVACODE
String determineTypeBase(String t1, String t2) {
    //   OP   # char   # int #  double
    //  # # # # # # # # # # # # # # #
    // char   # int      int    double
    // int    # int      int    double
    // double ä double  double  double
    if (t1.equals("double") || t2.equals("double")) return "double";

    return "int";
}

JAVACODE
String validateTypes(String left, String right, Token op) {
    if (right == null || op == null) // no point in type checking if no right expression exists
        return left;

    if (left.equals("error") || right.equals("error")) {
        System.out.printf("Invalid Type detected. Check types '%s' and '%s'.%n", left, right);
        return "error";
    }
    if (isNumeric(left) && isNumeric(right)) { // ok
        return determineTypeBase(left, right);
    } else { // numerics with non-numerics or string/boolean with string/boolean
        System.out.printf("Bad operator '%s' between types '%s' and '%s'.%n", op.image, left, right);
        return "error";
    }
}